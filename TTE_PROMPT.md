üß≠ TOOT-TOOT ENGINEERING PROMPT
# Meshtastic + MQTT + Semantic Bridge for **LILYGO T-Deck Plus (H737-03Mesh)**

Design and build a complete system that turns Meshtastic messages into **typed semantic events**, publishes them to **MQTT**, stores them in **MyMentalPalaceDB.md**, renders them in an offline **monitor.html**, and adds an AI ‚Äúlibrarian‚Äù that listens on MQTT and only speaks on the mesh when explicitly invoked.

This version is tailored for the **LILYGO T‚ÄëDeck Plus (H737‚Äë03Mesh)** as your primary field device.

---

## Assumptions and Hardware Notes (Tailored)
Treat the **T‚ÄëDeck Plus** as a **Meshtastic-capable ESP32-class handheld** with:
- **LoRa radio** supported by Meshtastic (commonly SX1262-class on many LILYGO boards)
- **Wi‚ÄëFi** (for MQTT uplink when available)
- **BLE** (for phone pairing/config and optional local control)
- **Keyboard + display** (useful for local status + ‚Äúgateway mode‚Äù controls)
- **Battery power** (support low-power behaviors)

**Do not hardcode pin mappings** in your first implementation. Instead:
- Use Meshtastic‚Äôs board support / device profile for the T‚ÄëDeck Plus variant.
- If you must set pins, implement them in one config file (e.g., `hardware_profile.py`) and keep the rest of the system generic.

---

## High-Level Goal
Build a **TTE-style semantic bridge** where:

**Meshtastic transport** ‚Üí **meaning extraction** ‚Üí **typed events + stable IDs** ‚Üí **MQTT distribution** ‚Üí **MyMentalPalaceDB graph memory** ‚Üí **Monitor UI** ‚Üí optional **AI librarian**

The bridge should work in two modes:

1. **T‚ÄëDeck Plus as a Gateway Node (Preferred)**
   - The T‚ÄëDeck Plus runs Meshtastic + a local ‚Äúsemantic bridge agent‚Äù
   - When Wi‚ÄëFi is available, it publishes semantic events to MQTT
   - When Wi‚ÄëFi is unavailable, it buffers events locally and forwards later

2. **T‚ÄëDeck Plus as a Standard Node**
   - A separate PC/RPi gateway listens to Meshtastic (serial/BLE/TCP)
   - The gateway does semantics + MQTT + DB + monitor
   - The T‚ÄëDeck Plus is just a rich UI node on the mesh

Design everything so the only difference is the **receiver transport** and **where the bridge runs**.

---

## Deliverables
Produce a repo-style project with:

1. `README.md` with setup for:
   - T‚ÄëDeck Plus gateway mode
   - External gateway mode (PC/RPi)
2. A running semantic bridge:
   - Meshtastic in
   - Semantic events out
3. MQTT topic taxonomy + sample payloads
4. `MyMentalPalaceDB.md` generated by the demo
5. Offline `monitor.html` that visualizes:
   - cursor panel
   - node graph + typed edges
   - filters
6. A simulation/demo generator that replays a ‚Äúday on the mesh‚Äù
7. `ai_librarian/` service that subscribes via MQTT

Use **Python 3.10** for the gateway-side implementation.
For on-device (if you implement gateway mode directly on the T‚ÄëDeck), you may use:
- **ESP-IDF / Arduino / MicroPython** as feasible, but keep the semantic core portable and testable in Python first.

---

## System Architecture (What to Build)
### Data Flow
Meshtastic packet ‚Üí Receiver ‚Üí Normalizer ‚Üí Semantic Interpreter ‚Üí Stable ID assignment ‚Üí MQTT publish ‚Üí MyMentalPalaceDB write ‚Üí Monitor render ‚Üí Optional AI librarian

### Modules
Create these modules/folders:

#### A) `receiver/`
Implement pluggable receivers:

- `receiver_meshtastic_tcp.py`  
  Connects to Meshtastic TCP API when available (good for gateway host or some networked setups).

- `receiver_meshtastic_serial.py`  
  Serial connection to a Meshtastic device (common for a PC/RPi gateway).

- `receiver_meshtastic_ble.py` (optional)  
  Useful if the T‚ÄëDeck is physically near the gateway host and BLE is easiest.

Each receiver must output a **NormalizedPacket**:
```json
{
  "from_id": "node:ridge-07",
  "to_id": "broadcast|node:xyz",
  "channel": "primary|secondary|‚Ä¶",
  "text": "TEMP 17.4",
  "ts": "2026-01-27T18:14:02Z",
  "rssi": -112,
  "snr": 6.5,
  "hop_count": 2,
  "location": {"lat": 43.6, "lon": -116.2, "alt": 800},
  "device_id": "‚Ä¶"
}
```

#### B) `semantic/`
Build a deterministic semantic interpreter with 2 modes:

1) `semantic_rules.py` (required)  
Table-driven intent grammar. Example patterns:
- `PING` ‚Üí `presence_probe`
- `STATUS?` ‚Üí `status_request`
- `OK` ‚Üí `acknowledgement`
- `TEMP <num>` ‚Üí `sensor_reading.temperature`
- `HELP MEDICAL` ‚Üí `emergency_medical`
- `@<node> <cmd>` ‚Üí `directed_command`
- `#broadcast <msg>` ‚Üí `bulletin_post`

2) `semantic_ai_enricher.py` (optional)  
Enriches classification and entities, but **never edits the raw message** and must output confidence + rationale fields.

Output a **SemanticEvent**:
```json
{
  "event_id": "44.1234,-116.2011",
  "event_type": "sensor_reading",
  "intent": "sensor_reading.temperature",
  "confidence": 0.92,
  "ts": "2026-01-27T18:14:02Z",
  "reported_by": "node:ridge-07",
  "addressed_to": "broadcast",
  "mesh_meta": {"rssi": -112, "snr": 6.5, "hop_count": 2, "channel": "primary"},
  "entities": [
    {"type": "node", "id": "node:ridge-07"},
    {"type": "sensor", "id": "sensor:temp"}
  ],
  "payload": {"value": 17.4, "unit": "C"},
  "edges": [
    {"edge_type": "reports_sensor", "from": "node:ridge-07", "to": "sensor:temp"}
  ],
  "raw_ref": "raw:sha256:‚Ä¶"
}
```

#### C) `addressing/`
Implement stable IDs and collision avoidance.

- Configure increments in DB prefix:
  - `ID_STEP_LAT`
  - `ID_STEP_LON`
- Collision rule:
  - If event_id exists, move South-East by one step repeatedly until unique.
- Provide a function:
  - `assign_event_id(normalized_packet, semantic_event) -> event_id`

#### D) `mqtt/`
Implement an MQTT semantic bus.

- Publish semantic events to:
  - `tte/event/<category>/<subcategory>`
- Also publish raw packets to:
  - `tte/raw/meshtastic`
- Publish node online/offline state:
  - `tte/state/node/<node_id>`

Example topic lanes (must implement):
- `tte/event/presence`
- `tte/event/sensor/temperature`
- `tte/event/emergency/medical`
- `tte/event/logistics/request`
- `tte/event/logistics/offer`
- `tte/event/bulletin/post`
- `tte/event/bulletin/reply`

Include a `topic_map.md` showing:
- topics
- payload schemas
- example messages

#### E) `db/`
Write semantic events to **MyMentalPalaceDB.md** with:
- Prefix settings (ID increments, collision rules)
- Records section
- Cursor section (auto-updatable)
- Typed edges glossary

Each record must include:
- Event ID
- Type + intent
- Who/where
- Raw reference
- Compact structured payload
- Typed edges

#### F) `monitor/`
Produce **offline** `monitor.html` that:
- Loads `MyMentalPalaceDB.md`
- Shows a cursor panel (selected record)
- Shows a graph (dot-style rendering acceptable)
- Filters by:
  - node
  - event_type
  - time range
- Highlights ‚Äústory trails‚Äù (paths via typed edges)

#### G) `ai_librarian/` (optional)
A service that subscribes to MQTT topics and can:
- Summarize last N hours
- Detect anomalies:
  - node silent
  - repeated SOS
  - sensor drift
- Answer questions by querying the DB

**Hard rule: AI only transmits to Meshtastic when invoked.**  
Invocation messages must be explicit and mesh-short:
- `@AI summarize 6h`
- `@AI status ridge-07`
- `@AI triage`

AI outputs must be compressed for mesh bandwidth.

---

## T‚ÄëDeck Plus Specific UX (Use the keyboard + display)
If the T‚ÄëDeck Plus is in gateway mode, implement a tiny ‚Äúoperator console‚Äù concept:

- Show current mode:
  - `NODE` (normal)
  - `GATEWAY` (MQTT uplink)
  - `BUFFERING` (offline store-and-forward)
- Key bindings (example, adapt freely):
  - `G` toggles gateway mode
  - `B` shows buffer depth
  - `S` shows mesh stats (RSSI/SNR/hops)
  - `M` shows MQTT connection status

Do not make the semantic bridge depend on UI. UI is optional garnish.

---

## Demonstration Scenario (Must Generate)
Create a simulated ‚Äúday on the mesh‚Äù with 5 nodes, including one named `node:tdeck-plus`:
- Presence pings
- 10 temperature readings
- 1 sensor alert
- 1 logistics request + offer
- 1 emergency medical event + acknowledgements
- 1 bulletin post thread with replies

Run it through the full pipeline and output:
- MQTT events (documented)
- `MyMentalPalaceDB.md`
- `monitor.html` that displays the graph

---

## Constraints
- Keep mesh-side deterministic and short.
- Be store-and-forward friendly.
- Pluggable transports.
- Python 3.10 for gateway code.
- Avoid hardcoding hardware pins; isolate in one config.

---

## Output Format Requested From the Agent
Return:
1. Design overview
2. Folder/module layout
3. Key schemas (NormalizedPacket, SemanticEvent)
4. MQTT taxonomy and topic map
5. MyMentalPalaceDB record template + typed edges glossary
6. Minimal runnable demo steps
7. Gateway mode plan for the T‚ÄëDeck Plus (Wi‚ÄëFi uplink + buffering)

---

## ‚ÄúDefinition of Done‚Äù
I can:
- Use the T‚ÄëDeck Plus on the mesh normally, and optionally as a gateway node when Wi‚ÄëFi is available.
- See semantic events arrive in MQTT.
- Open monitor.html offline and browse a graph of events and nodes.
- Query the DB and update the cursor panel.
- Ask @AI for summaries without spamming the mesh.

