üß≠ TOOT-TOOT ENGINEERING PROMPT
# Meshtastic + MQTT + TTN/TTDB Semantic Bridge for a 3-Node Field Network

Design a minimal, complete system that:
- Turns Meshtastic messages into **typed semantic events** (TTN-aligned).
- Publishes them to **MQTT**.
- Stores them in **MyMentalPalaceDB.md** (TTDB-aligned, with umwelt + globe semantics).
- Renders them in an offline **monitor.html**.
- Adds an AI ‚Äúlibrarian‚Äù that listens on MQTT and only speaks on the mesh when explicitly invoked.
- For technical clarifications, refer to the RFCs in the `RFCs/` folder.

This version targets a **3-node network** plus a Windows 11 gateway PC:
- **Node A (mesh):** LILYGO T‚ÄëDeck Plus (H737‚Äë03Mesh)
- **Node B (non-mesh):** Unihiker K10 (IP/Wi‚ÄëFi device)
- **Node C (non-mesh):** Any ESP32-class device (IP/Wi‚ÄëFi device)
- **Gateway/host:** Windows 11 PC running MQTT + TTN/TTDB pipeline

---

## Assumptions and Hardware Notes (Minimal)
- Do not hardcode pin mappings; isolate hardware pins in one config if required.
- Only the **T‚ÄëDeck Plus** is Meshtastic-capable and participates in the mesh.
- The **Unihiker K10** and **ESP32 node** are IP/Wi‚ÄëFi devices that do **not** run Meshtastic or LoRa.
- They communicate with the Windows 11 PC over IP (MQTT/HTTP/UDP), and the PC bridges their events into TTN.
- The Windows 11 PC is the primary **gateway** and MQTT host.
- LoRa setting for the T‚ÄëDeck (Step 1): **US LONG FAST** with center frequency **906.875 MHz**.

---

## Network Topology (Must Build)
1. **Windows 11 PC** runs:
   - MQTT broker
   - TTN semantic bridge (receiver + interpreter + MQTT publisher)
   - TTDB writer and offline monitor
   - AI librarian service
2. **T‚ÄëDeck Plus** runs Meshtastic and is the *only* mesh node.
3. **Unihiker K10** and **ESP32 node** connect to the Windows 11 PC over IP (Wi‚ÄëFi/Ethernet/USB).
4. The gateway PC ingests mesh packets from the T‚ÄëDeck via Meshtastic (serial/BLE/TCP as available).
5. The system bridges **IP ‚Üí TTN** and **TTN ‚Üí IP** via the gateway PC.

---

## High-Level Goal
Build a **TTN/TTDB semantic bridge** where:

**Meshtastic transport** ‚Üí **meaning extraction** ‚Üí **typed events + stable IDs** ‚Üí **MQTT distribution** ‚Üí **MyMentalPalaceDB graph memory** ‚Üí **Monitor UI** ‚Üí optional **AI librarian**

The bridge should work in two modes:

1. **T‚ÄëDeck Plus as a Gateway Node (Preferred)**
   - The T‚ÄëDeck Plus runs Meshtastic + a local ‚Äúsemantic bridge agent‚Äù
   - When Wi‚ÄëFi is available, it publishes semantic events to MQTT
   - When Wi‚ÄëFi is unavailable, it buffers events locally and forwards later

2. **T‚ÄëDeck Plus as a Standard Node**
   - A separate PC/RPi gateway listens to Meshtastic (serial/BLE/TCP)
   - The gateway does semantics + MQTT + DB + monitor
   - The T‚ÄëDeck Plus is just a rich UI node on the mesh

Design everything so the only difference is the **receiver transport** and **where the bridge runs**.

---

## Deliverables
Produce a repo-style project with:

1. `README.md` with setup for:
   - T‚ÄëDeck Plus gateway mode
   - External gateway mode (PC/RPi)
2. A running semantic bridge:
   - Meshtastic in
   - Semantic events out
3. MQTT topic taxonomy + sample payloads
4. `MyMentalPalaceDB.md` generated by the demo
5. Offline `monitor.html` that visualizes:
   - cursor panel
   - node graph + typed edges
   - filters
6. A simulation/demo generator that replays a ‚Äúday on the mesh‚Äù
7. `ai_librarian/` service that subscribes via MQTT
8. TTN deployment instructions for the 3-node network + Windows 11 PC

Use **Python 3.10** for the gateway-side implementation.
For on-device (if you implement gateway mode directly on the T‚ÄëDeck), you may use:
- **ESP-IDF / Arduino / MicroPython** as feasible, but keep the semantic core portable and testable in Python first.

---

## System Architecture (Minimal)
### Data Flow
Meshtastic packet ‚Üí Receiver ‚Üí Normalizer ‚Üí Semantic Interpreter ‚Üí Stable ID assignment ‚Üí MQTT publish ‚Üí MyMentalPalaceDB write ‚Üí Monitor render ‚Üí Optional AI librarian

### Modules
Create these modules/folders:

#### A) `receiver/`
Implement pluggable receivers:

- `receiver_meshtastic_tcp.py`  
  Connects to Meshtastic TCP API when available (good for gateway host or some networked setups).

- `receiver_meshtastic_serial.py`  
  Serial connection to a Meshtastic device (common for a PC/RPi gateway).

- `receiver_meshtastic_ble.py` (optional)  
  Useful if the T‚ÄëDeck is physically near the gateway host and BLE is easiest.

Each receiver must output a **NormalizedPacket**:
```json
{
  "from_id": "node:ridge-07",
  "to_id": "broadcast|node:xyz",
  "channel": "primary|secondary|‚Ä¶",
  "text": "TEMP 17.4",
  "ts": "2026-01-27T18:14:02Z",
  "rssi": -112,
  "snr": 6.5,
  "hop_count": 2,
  "location": {"lat": 43.6, "lon": -116.2, "alt": 800},
  "device_id": "‚Ä¶"
}
```

#### B) `semantic/`
Build a deterministic semantic interpreter with 2 modes:

1) `semantic_rules.py` (required)  
Table-driven intent grammar. Example patterns:
- `PING` ‚Üí `presence_probe`
- `STATUS?` ‚Üí `status_request`
- `OK` ‚Üí `acknowledgement`
- `TEMP <num>` ‚Üí `sensor_reading.temperature`
- `HELP MEDICAL` ‚Üí `emergency_medical`
- `@<node> <cmd>` ‚Üí `directed_command`
- `#broadcast <msg>` ‚Üí `bulletin_post`

2) `semantic_ai_enricher.py` (optional)  
Enriches classification and entities, but **never edits the raw message** and must output confidence + rationale fields.

Output a **SemanticEvent**:
```json
{
  "event_id": "44.1234,-116.2011",
  "event_type": "sensor_reading",
  "intent": "sensor_reading.temperature",
  "confidence": 0.92,
  "ts": "2026-01-27T18:14:02Z",
  "reported_by": "node:ridge-07",
  "addressed_to": "broadcast",
  "mesh_meta": {"rssi": -112, "snr": 6.5, "hop_count": 2, "channel": "primary"},
  "entities": [
    {"type": "node", "id": "node:ridge-07"},
    {"type": "sensor", "id": "sensor:temp"}
  ],
  "payload": {"value": 17.4, "unit": "C"},
  "edges": [
    {"edge_type": "reports_sensor", "from": "node:ridge-07", "to": "sensor:temp"}
  ],
  "raw_ref": "raw:sha256:‚Ä¶"
}
```

#### C) `addressing/`
Implement stable IDs and collision avoidance.

- Configure increments in DB prefix:
  - `ID_STEP_LAT`
  - `ID_STEP_LON`
- Collision rule:
  - If event_id exists, move South-East by one step repeatedly until unique.
- Provide a function:
  - `assign_event_id(normalized_packet, semantic_event) -> event_id`

#### D) `mqtt/`
Implement an MQTT semantic bus.

- Publish semantic events to:
  - `tte/event/<category>/<subcategory>`
- Also publish raw packets to:
  - `tte/raw/meshtastic`
- Publish node online/offline state:
  - `tte/state/node/<node_id>`

Example topic lanes (must implement):
- `tte/event/presence`
- `tte/event/sensor/temperature`
- `tte/event/emergency/medical`
- `tte/event/logistics/request`
- `tte/event/logistics/offer`
- `tte/event/bulletin/post`
- `tte/event/bulletin/reply`

Include a `topic_map.md` showing:
- topics
- payload schemas
- example messages

#### E) `db/`
Write semantic events to **MyMentalPalaceDB.md** with:
- Prefix settings (ID increments, collision rules)
- Records section
- Cursor section (auto-updatable)
- Typed edges glossary
- Umwelt block (librarian perspective + globe mapping)
- Librarian primitive query settings

Each record must include:
- Event ID
- Type + intent
- Who/where
- Raw reference
- Compact structured payload
- Typed edges

#### F) `monitor/`
Produce **offline** `monitor.html` that:
- Loads `MyMentalPalaceDB.md`
- Shows a cursor panel (selected record)
- Shows a graph (dot-style rendering acceptable)
- Filters by:
  - node
  - event_type
  - time range
- Highlights ‚Äústory trails‚Äù (paths via typed edges)

#### G) `ai_librarian/` (optional)
A service that subscribes to MQTT topics and can:
- Summarize last N hours
- Detect anomalies:
  - node silent
  - repeated SOS
  - sensor drift
- Answer questions by querying the DB

**Hard rule: AI only transmits to Meshtastic when invoked.**  
Invocation messages must be explicit and mesh-short:
- `@AI summarize 6h`
- `@AI status ridge-07`
- `@AI triage`

AI outputs must be compressed for mesh bandwidth.

---

## Minimal Device UX (Optional)
UI is optional garnish; the semantic bridge must not depend on device UI.

---

## Demonstration Scenario (Must Generate)
Create a simulated ‚Äúday on the mesh‚Äù with 3 nodes (hybrid):
- `node:tdeck-plus`
- `node:unihiker-k10`
- `node:esp32-field`
- Presence pings
- 10 temperature readings
- 1 sensor alert
- 1 logistics request + offer
- 1 emergency medical event + acknowledgements
- 1 bulletin post thread with replies

Run it through the full pipeline and output:
- MQTT events (documented)
- `MyMentalPalaceDB.md`
- `monitor.html` that displays the graph

---

## Constraints
- Keep mesh-side deterministic and short.
- Be store-and-forward friendly.
- Pluggable transports.
- Python 3.10 for gateway code.
- Avoid hardcoding hardware pins; isolate in one config.
- If adding LoRa-only nodes, use `RFCs/TTN-RFC-0006-LoRa-Packet-Framing.md`.

---

## Output Format Requested From the Agent
Return:
1. Design overview
2. Folder/module layout
3. Key schemas (NormalizedPacket, SemanticEvent)
4. MQTT taxonomy and topic map
5. MyMentalPalaceDB record template + typed edges glossary
6. Minimal runnable demo steps
7. Gateway mode plan for the T‚ÄëDeck Plus (Wi‚ÄëFi uplink + buffering)
8. TTN deployment steps for Windows 11 PC + 3-node hybrid mesh/IP network

---

## ‚ÄúDefinition of Done‚Äù
I can:
- Use the T‚ÄëDeck Plus on the mesh normally, and optionally as a gateway node when Wi‚ÄëFi is available.
- See semantic events arrive in MQTT.
- Open monitor.html offline and browse a graph of events and nodes.
- Query the DB and update the cursor panel.
- Ask @AI for summaries without spamming the mesh.
