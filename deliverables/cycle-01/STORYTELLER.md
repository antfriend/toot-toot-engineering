# STORYTELLER (cycle-01)

## Narrative goal: “modem-era calm”
This BBS should feel like calling into a small town switchboard: deliberate pacing, short lines, and a server that never floods the client.

The *story* here is not plot-heavy; it’s **experience design**:
- The system is patient.
- The system is predictable.
- The system is kind to bad connections.

## Voice & tone guidelines (copy rules)
- Use **plain ASCII**.
- Prefer **short sentences**.
- Avoid decoration that costs bytes.
- Always end lines with `\r\n`.
- When output could exceed ~15–20 lines, page it and wait for a single-keystroke continue.
- When the user does something, respond with a short confirmation (`OK ...`) before showing the next screen.

Suggested micro-copy patterns:
- Confirmations: `OK`, `OK LOGIN`, `OK POSTED`, `ERR ...`
- Prompts: `HANDLE? `, `> `, `CHOICE? `
- Soft guidance: `TIP: TYPE MENU`

## “BBS magic” moments (where it should feel real)
1. **The banner**: a compact identity.
   - Example:
     - `TOOT-TOOT BBS (K10)`
     - `LOW BANDWIDTH MODE`
     - `TYPE HELLO`
2. **The pause**: never assume the client can swallow a dump.
   - A `--MORE-- (ENTER)` gate provides the classic rhythm.
3. **The menu**: consistent, numbered, and forgiving.
   - Always offer a way back to `MENU`.

## Screen inventory (what screens should exist)
These should be generated by `screens.py` so the rest of the system stays byte-cheap and consistent.

### SCR WELCOME
- Shown immediately on connect.
- Tells the user how to proceed.

### SCR LOGIN
- Minimal.
- One field: handle.

### SCR MENU MAIN
Numbered choices, plus command aliases:
1. Areas
2. Read
3. Post
4. Help
5. Bye

### SCR AREAS
- List area names and IDs (IDs can be short; underlying node IDs can be long).

### SCR LIST AREA <name>
- Show latest N message headers in that area: id, author, timestamp (short), first ~30 chars.

### SCR READ
- Show a message with a header.
- Support offsets: if offset is provided, show “CONTINUED” header.

### SCR POST
- Confirm constraints: ASCII only, max bytes.
- If client disconnects mid-post, server keeps a draft stub (recoverable).

## Protocol UX guidance (for the Core Worker)
Even though we have a line command protocol, we should support a menu-driven flow by mapping menu selections to the same commands.

Rules:
- Accept both `MENU` and `?` as menu request.
- Accept `1`/`AREAS` to show areas.
- Accept `R <id>` as alias for `READ <id>`.
- Keep errors terse:
  - `ERR UNKNOWN CMD`
  - `ERR NOT LOGGED IN`
  - `ERR BAD OFFSET`

Paging:
- The protocol can express screens as:
  - `SCR <name>` then `TXT <nbytes>` then body then `END`
- If body exceeds a page budget, send:
  - `SCR <name>`
  - `TXT <nbytes>`
  - `<page bytes>`
  - `MORE` (client replies `MORE` or just presses ENTER)
  - Continue with next chunk.

## Data/story alignment (MMPDB “feels like a place”)
Treat **areas as locations** and messages as “notes pinned to the wall.”
- Areas are nodes.
- Messages link to areas via `in_area` edges.
- Threads link via `thread_root` and `reply_to` edges.

This structure enables future transports (Meshtastic-like) to sync nodes/edges without rewriting the BBS.

## Deliverable alignment checklist for later steps
- Ensure menus never exceed page budget.
- Ensure all default screens exist.
- Ensure copy is consistent with low-bandwidth philosophy.

