<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>MyMentalPalaceDB Monitor</title>
    <style>
      :root {
        --bg: #0f0f12;
        --panel: #17171c;
        --panel-border: #2a2a33;
        --text: #e9e9f0;
        --muted: #a7a7b3;
        --accent: #ffb84d;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "IBM Plex Mono", "Fira Code", "Cascadia Mono", "Source Code Pro", Menlo,
          Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        background: radial-gradient(circle at top, #1a1a21 0%, #0f0f12 60%);
        color: var(--text);
        min-height: 100vh;
      }

      body::after {
        content: "";
        position: fixed;
        left: 0;
        right: 0;
        top: -4px;
        height: 4px;
        pointer-events: none;
        background: rgba(0, 255, 140, 0.6);
        box-shadow: 0 0 16px rgba(0, 255, 140, 0.55);
        mix-blend-mode: screen;
        opacity: 0.85;
        transform-origin: top center;
        animation: scanline 11s infinite;
        animation-timing-function: cubic-bezier(0.15, 0.8, 0.2, 1);
      }

      @keyframes scanline {
        0% { transform: translateY(-12px) scaleY(1); opacity: 0.35; }
        8% { transform: translateY(70vh) scaleY(0.7); opacity: 0.85; }
        16% { transform: translateY(100vh) scaleY(0.35); opacity: 0.25; }
        18.18% { transform: translateY(110vh) scaleY(0); opacity: 0; }
        18.19% { transform: translateY(-12px) scaleY(1); opacity: 0.35; }
        26.18% { transform: translateY(70vh) scaleY(0.7); opacity: 0.85; }
        34.18% { transform: translateY(100vh) scaleY(0.35); opacity: 0.25; }
        36.36% { transform: translateY(110vh) scaleY(0); opacity: 0; }
        36.37% { transform: translateY(-12px) scaleY(1); opacity: 0.35; }
        44.36% { transform: translateY(70vh) scaleY(0.7); opacity: 0.85; }
        52.36% { transform: translateY(100vh) scaleY(0.35); opacity: 0.25; }
        54.54% { transform: translateY(110vh) scaleY(0); opacity: 0; }
        54.55% { transform: translateY(-12px) scaleY(1); opacity: 0; }
        100% { transform: translateY(-12px) scaleY(1); opacity: 0; }
      }

      header {
        padding: 16px 20px;
        border-bottom: 1px solid var(--panel-border);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      header h1 {
        margin: 0;
        font-size: 18px;
        letter-spacing: 0.06em;
        text-transform: uppercase;
      }

      header .meta {
        color: var(--muted);
        font-size: 12px;
      }

      .current-step-bar {
        margin: 0 16px 6px;
        padding: 10px 16px;
        border-radius: 12px;
        border: 1px solid rgba(0, 255, 140, 0.35);
        background: linear-gradient(90deg, rgba(0, 255, 140, 0.12), rgba(0, 255, 140, 0.02));
        color: #b8ffe1;
        text-shadow: 0 0 10px rgba(0, 255, 140, 0.65);
        box-shadow: 0 0 18px rgba(0, 255, 140, 0.35);
        font-size: 18px;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
      }

      .current-step-bar span {
        color: #e9fff6;
        text-transform: none;
        letter-spacing: 0;
        font-weight: 600;
        font-size: 18px;
      }

      main {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 16px;
        padding: 16px;
      }

      .panel {
        background: var(--panel);
        border: 1px solid var(--panel-border);
        border-radius: 12px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        min-height: 55vh;
        box-shadow: 0 0 0 1px rgba(0, 255, 140, 0.06), 0 0 22px rgba(0, 255, 140, 0.12),
          inset 0 0 18px rgba(0, 255, 140, 0.08);
        position: relative;
      }

      .panel::before {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 12px;
        background: radial-gradient(circle at 20% 10%, rgba(0, 255, 140, 0.12), transparent 45%),
          radial-gradient(circle at 80% 90%, rgba(0, 160, 255, 0.08), transparent 50%);
        opacity: 0.55;
        mix-blend-mode: screen;
        pointer-events: none;
        animation: panelGlow 6s ease-in-out infinite;
      }

      @keyframes panelGlow {
        0% { opacity: 0.35; filter: blur(0px); }
        50% { opacity: 0.7; filter: blur(2px); }
        100% { opacity: 0.35; filter: blur(0px); }
      }

      .panel header {
        border-bottom: 1px solid var(--panel-border);
        padding: 10px 14px;
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        background: #1f1f26;
        text-shadow: 0 0 12px rgba(0, 255, 140, 0.35);
        position: relative;
        z-index: 1;
      }

      .panel .markdown,
      .panel pre {
        margin: 0;
        padding: 14px;
        overflow: auto;
        flex: 1;
        position: relative;
        z-index: 1;
      }

      .panel pre {
        white-space: pre-wrap;
        word-break: break-word;
        font-size: 12px;
        line-height: 1.5;
      }

      .panel .markdown {
        font-size: 13px;
        line-height: 1.6;
        color: var(--text);
        text-shadow: 0 0 10px rgba(0, 255, 140, 0.2);
      }

      .markdown h1,
      .markdown h2,
      .markdown h3 {
        margin: 0 0 10px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .markdown p { margin: 0 0 10px; }
      .markdown ul { margin: 0 0 10px 18px; padding: 0; }
      .markdown li { margin: 0 0 6px; }

      .markdown code {
        font-family: "SFMono-Regular", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New",
          monospace;
        background: #1c1c24;
        border: 1px solid var(--panel-border);
        padding: 1px 5px;
        border-radius: 6px;
        font-size: 12px;
      }

      .markdown a { color: var(--accent); text-decoration: none; }
      .markdown a:hover { text-decoration: underline; }

      .markdown pre {
        background: #1c1c24;
        border: 1px solid var(--panel-border);
        padding: 12px;
        border-radius: 8px;
        overflow: auto;
      }

      .status { color: var(--accent); }
      .error { color: #ff7b7b; }
      .muted { color: var(--muted); }

      /* Graph area */
      .graph-wrap {
        padding: 10px 14px 14px;
      }
      #graph svg {
        width: 100%;
        height: auto;
      }

      /* Node list buttons */
      .node-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .node-btn {
        text-align: left;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid var(--panel-border);
        background: #1c1c24;
        color: var(--text);
        cursor: pointer;
        text-shadow: 0 0 10px rgba(0, 255, 140, 0.15);
      }
      .node-btn:hover {
        border-color: rgba(0, 255, 140, 0.45);
        box-shadow: 0 0 14px rgba(0, 255, 140, 0.15);
      }
      .small {
        font-size: 11px;
        color: var(--muted);
      }
    </style>
  </head>

  <body>
    <header>
      <h1>MyMentalPalaceDB Monitor</h1>
      <div class="meta">
        DB: <span class="status" id="db-path">(loading)</span> · Refresh:
        <span class="status" id="refresh-interval">—</span> · Last update:
        <span id="last-updated" class="muted">—</span>
      </div>
    </header>

    <div class="current-step-bar">
      <div>
        Selected: <span id="selected-id">None</span>
      </div>
      <div class="small" id="stats">records: — · edges: —</div>
    </div>

    <main>
      <section class="panel">
        <header>DB CONFIG (```mmpdb)</header>
        <div id="cfg" class="markdown">Loading…</div>
      </section>

      <section class="panel">
        <header>CURSOR (```cursor)</header>
        <div id="cursor" class="markdown">Loading…</div>
      </section>

      <section class="panel">
        <header>SELECTED RECORD (preview)</header>
        <pre id="selected-preview">Click a node to preview its record content.</pre>
      </section>

      <section class="panel">
        <header>NODES</header>
        <div class="markdown">
          <div class="node-list" id="node-list">Loading…</div>
        </div>
      </section>

      <section class="panel" style="grid-column: 1 / -1; min-height: 70vh;">
        <header>GRAPH (ALL NODES AND DIRECTED EDGES)</header>
        <div class="graph-wrap">
          <div id="graph" class="markdown">Rendering…</div>
        </div>
      </section>
    </main>

    <!-- Viz.js for DOT rendering -->
    <script src="https://cdn.jsdelivr.net/npm/viz.js@2.1.2/viz.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/viz.js@2.1.2/full.render.js"></script>

    <script>
      // --- CONFIG ---
      const REFRESH_MS = 3000;

      // Set this to your actual DB filename in the repo:
      const DB_PATH = "MyMentalPalaceDB.md";

      // --- DOM ---
      const cfgEl = document.getElementById("cfg");
      const cursorEl = document.getElementById("cursor");
      const selectedPreviewEl = document.getElementById("selected-preview");
      const nodeListEl = document.getElementById("node-list");
      const graphEl = document.getElementById("graph");
      const lastUpdatedEl = document.getElementById("last-updated");
      const refreshIntervalEl = document.getElementById("refresh-interval");
      const dbPathEl = document.getElementById("db-path");
      const selectedIdEl = document.getElementById("selected-id");
      const statsEl = document.getElementById("stats");

      refreshIntervalEl.textContent = `${REFRESH_MS / 1000}s`;
      dbPathEl.textContent = DB_PATH;

      let state = {
        text: "",
        records: [],
        edges: 0,
        selectedId: null,
        cfgBlock: null,
        cursorBlock: null,
      };

      // --- helpers borrowed from your monitor.html style ---
      function escapeHtml(text) {
        return text
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }

      function escapeInline(text) {
        const linkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
        const chunks = [];
        let lastIndex = 0;
        let match;

        while ((match = linkRegex.exec(text))) {
          const before = text.slice(lastIndex, match.index);
          chunks.push(escapeHtml(before));
          const label = escapeHtml(match[1]);
          const href = escapeHtml(match[2]);
          chunks.push(`<a href="${href}">${label}</a>`);
          lastIndex = match.index + match[0].length;
        }

        chunks.push(escapeHtml(text.slice(lastIndex)));
        let output = chunks.join("");
        output = output.replace(/`([^`]+)`/g, "<code>$1</code>");
        output = output.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");
        output = output.replace(/\*([^*]+)\*/g, "<em>$1</em>");
        return output;
      }

      function renderMarkdown(md) {
        const blocks = md.split(/```/g);
        const htmlParts = [];

        blocks.forEach((block, index) => {
          if (index % 2 === 1) {
            htmlParts.push(
              `<pre><code>${escapeHtml(block.replace(/^\n+|\n+$/g, ""))}</code></pre>`
            );
            return;
          }

          const lines = block.split("\n");
          let inList = false;

          lines.forEach((line) => {
            const trimmed = line.trim();

            if (!trimmed) {
              if (inList) {
                htmlParts.push("</ul>");
                inList = false;
              }
              return;
            }

            const headerMatch = trimmed.match(/^(#{1,3})\s+(.*)$/);
            if (headerMatch) {
              if (inList) {
                htmlParts.push("</ul>");
                inList = false;
              }
              const level = headerMatch[1].length;
              htmlParts.push(`<h${level}>${escapeHtml(headerMatch[2])}</h${level}>`);
              return;
            }

            const listMatch = trimmed.match(/^-\s+(.*)$/);
            if (listMatch) {
              if (!inList) {
                htmlParts.push("<ul>");
                inList = true;
              }
              htmlParts.push(`<li>${escapeInline(listMatch[1])}</li>`);
              return;
            }

            if (inList) {
              htmlParts.push("</ul>");
              inList = false;
            }

            htmlParts.push(`<p>${escapeInline(trimmed)}</p>`);
          });

          if (inList) {
            htmlParts.push("</ul>");
          }
        });

        return htmlParts.join("");
      }

      async function loadText(path, cacheBuster) {
        const url = `${path}?t=${cacheBuster}`;
        const resp = await fetch(url, { cache: "no-store" });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        return await resp.text();
      }

      function extractFencedBlock(text, fenceName) {
        const re = new RegExp("```" + fenceName + "\\n([\\s\\S]*?)\\n```", "m");
        const m = text.match(re);
        return m ? m[1].trim() : null;
      }

      function parseRecords(text) {
        // Prefix line:
        // @LAT0LON0 | created:170... | updated:170... | relates:...
        const prefixRe =
          /^(@LAT-?\d+LON-?\d+)\s*\|\s*created:(\d+)\s*\|\s*updated:(\d+)(?:\s*\|\s*relates:([^\n]+))?\s*$/;

        const lines = text.split(/\r?\n/);
        const records = [];
        let cur = null;

        for (const ln of lines) {
          const m = ln.match(prefixRe);
          if (m) {
            if (cur) records.push(cur);
            const id = m[1];
            const created = Number(m[2]);
            const updated = Number(m[3]);
            const relatesRaw = (m[4] || "").trim();
            const relates = relatesRaw
              ? relatesRaw.split(",").map(s => s.trim()).filter(Boolean)
              : [];
            cur = { id, created, updated, relates, contentLines: [] };
            continue;
          }
          if (cur) cur.contentLines.push(ln);
        }
        if (cur) records.push(cur);

        for (const r of records) {
          const content = r.contentLines.join("\n").trim();
          r.content = content;
          r.preview = content.replace(/\s+/g, " ").slice(0, 500);
        }
        return records;
      }

      function buildDotAll(records) {
        // note: we keep DOT simple; styling can be layered later
        const esc = (s) => s.replace(/"/g, '\\"');
        const lines = [];
        let edgeCount = 0;

        for (const r of records) {
          if (r.relates.length === 0) {
            lines.push(`  "${esc(r.id)}";`);
            continue;
          }
          for (const t of r.relates) {
            edgeCount += 1;
            lines.push(`  "${esc(r.id)}" -> "${esc(t)}";`);
          }
        }

        return {
          dot:
            `digraph MyMentalPalaceDB {\n` +
            `  rankdir=LR;\n` +
            `  node [shape=box, fontname="IBM Plex Mono"];\n` +
            `  edge [fontname="IBM Plex Mono"];\n` +
            lines.join("\n") +
            `\n}\n`,
          edgeCount
        };
      }

      async function renderDot(dot) {
        const viz = new Viz();
        try {
          const svg = await viz.renderSVGElement(dot);
          graphEl.innerHTML = "";
          graphEl.appendChild(svg);
        } catch (err) {
          graphEl.innerHTML = `<pre class="error">DOT render error:\n${escapeHtml(String(err))}\n\n${escapeHtml(dot)}</pre>`;
        }
      }

      function setSelected(id) {
        state.selectedId = id;
        selectedIdEl.textContent = id || "None";
        const rec = state.records.find(r => r.id === id);
        if (!rec) {
          selectedPreviewEl.textContent = `No record found for ${id}`;
          return;
        }
        selectedPreviewEl.textContent =
          `${rec.id} | created:${rec.created} updated:${rec.updated}\n` +
          `relates: ${rec.relates.join(", ") || "(none)"}\n\n` +
          `${rec.preview}${rec.content.length > rec.preview.length ? "…" : ""}`;
      }

      function renderNodeList(records) {
        nodeListEl.innerHTML = "";
        const sorted = [...records].sort((a, b) => a.id.localeCompare(b.id));
        for (const r of sorted) {
          const btn = document.createElement("button");
          btn.className = "node-btn";
          btn.textContent = r.id;
          btn.onclick = () => setSelected(r.id);
          nodeListEl.appendChild(btn);
        }
        if (sorted.length === 0) {
          nodeListEl.innerHTML = `<p class="muted">No records found.</p>`;
        }
      }

      async function refresh() {
        const cacheBuster = Date.now();

        let text;
        try {
          text = await loadText(DB_PATH, cacheBuster);
        } catch (err) {
          cfgEl.innerHTML = `<p class="error">Failed to load ${escapeHtml(DB_PATH)}: ${escapeHtml(err.message)}</p>`;
          cursorEl.innerHTML = `<p class="error">Failed to load DB.</p>`;
          nodeListEl.innerHTML = `<p class="error">No nodes.</p>`;
          graphEl.innerHTML = `<pre class="error">No graph.</pre>`;
          return;
        }

        state.text = text;
        state.cfgBlock = extractFencedBlock(text, "mmpdb");
        state.cursorBlock = extractFencedBlock(text, "cursor");

        // Render config and cursor as markdown
        cfgEl.innerHTML = state.cfgBlock ? renderMarkdown(state.cfgBlock) : `<p class="muted">(no \`\`\`mmpdb block found)</p>`;
        cursorEl.innerHTML = state.cursorBlock ? renderMarkdown(state.cursorBlock) : `<p class="muted">(no \`\`\`cursor block found)</p>`;

        // Parse records
        state.records = parseRecords(text);

        // Build + render DOT graph
        const { dot, edgeCount } = buildDotAll(state.records);
        state.edges = edgeCount;
        await renderDot(dot);

        // Stats
        statsEl.textContent = `records: ${state.records.length} · edges: ${state.edges}`;

        // Node list
        renderNodeList(state.records);

        // Preserve selection if possible
        if (state.selectedId && state.records.some(r => r.id === state.selectedId)) {
          setSelected(state.selectedId);
        } else if (state.records.length) {
          setSelected(state.records[0].id);
        } else {
          setSelected(null);
        }

        lastUpdatedEl.textContent = new Date().toLocaleTimeString();
      }

      refresh();
      setInterval(refresh, REFRESH_MS);
    </script>
  </body>
</html>
